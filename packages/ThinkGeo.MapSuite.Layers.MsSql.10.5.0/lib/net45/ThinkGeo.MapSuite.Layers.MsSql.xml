<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ThinkGeo.MapSuite.Layers.MsSql</name>
    </assembly>
    <members>
        <member name="T:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementMsSqlFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the ExecutingSqlStatement event in MsSqlFeatureSource.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementMsSqlFeatureSourceEventArgs.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="sqlStatement">This parameter is the sqlStatement that will be passed in to excute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementMsSqlFeatureSourceEventArgs.#ctor(System.String,ThinkGeo.MapSuite.Layers.ExecutingSqlStatementType)">
            <summary>This is a constructor for the class.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="sqlStatement">This parameter is the sqlStatement that will be passed in to excute.</param>
            <param name="sqlStatementType">This parameter is the sqlStatementType for this sqlStatement to be excuted.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementMsSqlFeatureSourceEventArgs.SqlStatement">
            <summary>This property gets and sets the SqlStatement that will be excuted.</summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ExecutingSqlStatementMsSqlFeatureSourceEventArgs.ExecutingSqlStatementType">
            <summary>This property gets and sets the SqlStatementType of the SqlStatement that will be excuted.</summary>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MsSqlExceptionDescription">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlExceptionDescription.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlExceptionDescription.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlExceptionDescription.EnumerationOutOfRange">
            <summary>
              Looks up a localized string similar to The value for the enumeration is not one of the valid values..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlExceptionDescription.GeometriesInvalidExist">
            <summary>
              Looks up a localized string similar to We have found geometries that are invalid according to the SQL Server STIsValid() Function. To automaticly fix these you can call the MakeAllGeometriesValid method. The SQL To Determine which records are invalid:.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlExceptionDescription.InvalidGeometryInMsSqlForSpatialQuery">
            <summary>
              Looks up a localized string similar to There&apos;re some invalid geometry instance in table not valid. About invalid geometry please have a look at http://msdn.microsoft.com/en-us/library/bb933890.aspx website. To solve this problem, we provide MakeAllGeometryValid function to make the invalid geometry to be valid, because of the function updating your data, you need to backup your data before using this function..
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer">
            <summary>This class represents a layer backed by Microsoft SQL Server.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor, but it is not typically used.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.#ctor(System.String,System.String,System.String)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            Layer.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string that will be used to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            Layer.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string that will be used to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
            <param name="srid">Specify what kind srid data to be used.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.CommandTimeout">
            <summary>
            This property gets and sets the amount of time that can elapse before the command will
            timeout and abort.
            </summary>
            <value>
            This property gets the amount of time that can elapse before the command will timeout and
            abort.
            </value>
            <remarks>You can use this to set a time limit for the query before it times out.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.ConnectionString">
            <summary>
            This property gets and sets the connection string that will be used to connect to the
            server.
            </summary>
            <value>This property gets the connection string that will be used to connect to the server.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.TableName">
            <summary>This property gets or sets the table name that the database will use.</summary>
            <value>This property gets the table name that the database will use.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In MsSqlFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.Srid">
            <summary>
            Specify what kind srid data to be used.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.FeatureIdColumn">
            <summary>
            This property gets or sets the name of the column that holds the unique feature
            Id.
            </summary>
            <value>
            This property gets the name of the column that holds the unique feature
            Id.
            </value>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.Validate">
            <summary>
            Check if all geometry are valid for spatial query.
            </summary>
            <returns>If all geometry are valid, the count of the returning dictionary is 0.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.BuildIndex(ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            Build Spatial index
            </summary>
            <param name="buildIndexMode">Build Index Mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.MakeAllGeometriesValid">
            <summary>
            To make the geometry type data valid, and update the table.
            </summary>
            <remarks>
                This function will check whether the geometry is valid for spatial query,
                if it is not, then the function will make it valid and save it back to the
                table.
                For example: Here's a invalid LineString LINESTRING(0 2,1 1,1 0,1 1,2 2))
                which is overlaps itself, it's invalid. After use this function, it will be
                MULTILINESTRING((0 2,1 1,2 2),(1 1,1 0))
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.GetFirstGeometryType">
            <summary>
            Get The shape type from the first record.
            </summary>
            <returns>The shape type of the first record.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.ExecuteNonQuery(System.String)">
            <summary>This method executes a query that does not return a SQL result.</summary>
            <returns>None</returns>
            <remarks>This methods executes a query that has no results.</remarks>
            <param name="sqlStatement">This parameter represents the SQL statement that will be executed.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.CreateTable(System.String,System.String,ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType)">
            <summary>
            This method creates a Sql Spatial Data table in MsSql server.
            </summary>
            <param name="connectionString">Represents the connection string to the database</param>
            <param name="tableName">Represents the name for the table</param>
            <param name="spatialDataType">Represents the Spatial Data Type for the Spatial Data column</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.CreateTable(System.String,System.String,ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn})">
            <summary>
            This method creates a Sql Spatial Data table in Ms SQL Server.
            </summary>
            <param name="connectionString">Represents the connection string to the database</param>
            <param name="tableName">Represents the name for the table</param>
            <param name="spatialDataType">Represents the Spatial Data Type for the Spatial Data column</param>
            <param name="columns">Represnts information for creating columns besides Spatial Data Column</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureLayer.CreateTable(System.String,System.String,ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn},ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            This method creates a Sql Spatial Data table in Ms SQL Server.
            </summary>
            <param name="connectionString">Represents the connection string to the database</param>
            <param name="tableName">Represents the name for the table</param>
            <param name="spatialDataType">Represents the Spatial Data Type for the Spatial Data column</param>
            <param name="columns">Represnts information for creating columns besides Spatial Data Column</param>
            <param name="overwriteMode">Indicates whether need to overwrite the datatable if there's already an exsited one</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource">
            <summary>This class represents a FeatureSource backed by MS SQL Server.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.#ctor">
            <summary>This is the constructor for the class.</summary>
            <overloads>This is the default constructor but it is not typically used.</overloads>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.#ctor(System.String,System.String,System.String)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            FeatureSource.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in all of the data to create the
            FeatureSource.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="connectionString">This parameter represents the connection string to connect to the server.</param>
            <param name="tableName">This parameter represents the table name being accessed.</param>
            <param name="featureIdColumn">
            This parameter represents the name of the column that holds the unique feature
            Id.
            </param>
            <param name="srid">Specify what kind srid data to be used.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CommandTimeout">
            <summary>This property gets and sets the time maximum for a command to complete.</summary>
            <decimalDegreesValue>This property gets the time maximum for a command to complete.</decimalDegreesValue>
            <remarks>This property allows you to set a timeout of a command.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CanExecuteSqlQueryCore">
            <summary>
            This property specifies the FeatureSource can excute sql query or not.
            If it is false, then it will throw exception when called the APIs:ExecuteScalar,ExecuteNonQuery,ExecuteQuery
            This orverides will make it true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.ConnectionString">
            <summary>
            This property gets and sets the connection string used to connect to the
            server.
            </summary>
            <decimalDegreesValue>This property gets the connection string used to connect to the server.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.TableName">
            <summary>This property gets or sets the table name the database will use.</summary>
            <decimalDegreesValue>This property gets the table name the database will use.</decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.FeatureIdColumn">
            <summary>
            This property gets or sets the name of the column that holds the unique feature
            Id.
            </summary>
            <decimalDegreesValue>
            This property gets the name of the column that holds the unique feature
            Id.
            </decimalDegreesValue>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.SpatialDataType">
            <summary>This property gets the spatial data type in the MsSqlFeatureSource.</summary>
            <value>This property gets the spatial data type in the MsSqlFeatureSource.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.Srid">
            <summary>
            Specify what kind srid data to be used.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.ExecutingSqlStatement">
            <summary>
            This event will be fired every time the sql statement is excuted.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.OnExecutingSqlStatement(ThinkGeo.MapSuite.Layers.ExecutingSqlStatementMsSqlFeatureSourceEventArgs)">
            <summary>This method allows you to raise the ExecutingSqlStatement event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the ExecutingSqlStatement event. Normally events are not
            accessible to derived classes so we exposed a way to raise the event is necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the ExecutingSqlStatement
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CreateTable(System.String,System.String,ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType)">
            <summary>
            This method creates a Sql Spatial Data table in Ms SQL Server.
            </summary>
            <param name="connectionString">Represents the connection string to the database</param>
            <param name="tableName">Represents the name for the table</param>
            <param name="spatialDataType">Represents the Spatial Data Type for the Spatial Data column</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CreateTable(System.String,System.String,ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn})">
            <summary>
            This method creates a Sql Spatial Data table in Ms SQL Server.
            </summary>
            <param name="connectionString">Represents the connection string to the database</param>
            <param name="tableName">Represents the name for the table</param>
            <param name="spatialDataType">Represents the Spatial Data Type for the Spatial Data column</param>
            <param name="columns">Represnts information for creating columns besides Spatial Data Column</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CreateTable(System.String,System.String,ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.FeatureSourceColumn},ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            This method creates a Sql Spatial Data table in Ms SQL Server.
            </summary>
            <param name="connectionString">Represents the connection string to the database</param>
            <param name="tableName">Represents the name for the table</param>
            <param name="spatialDataType">Represents the Spatial Data Type for the Spatial Data column</param>
            <param name="columns">Represnts information for creating columns besides Spatial Data Column</param>
            <param name="overwriteMode">Indicates whether need to overwrite the datatable if there's already an exsited one</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.BuildIndex(ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            Build Spatial index
            </summary>
            <param name="buildIndexMode">Build Index Mode</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.Validate">
            <summary>
            Check if all geometry are valid for spatial query.
            </summary>
            <returns>If all geometry are valid, the count of the returning dictionary is 0.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.MakeAllGeometriesValid">
            <summary>
            To make the geometry type data valid, and update the table.
            </summary>
            <remarks>
                This function will check whether the geometry is valid for spatial query,
                if it is not, then the function will make it valid and save it back to the
                table.
                For example: Here's a invalid LineString LINESTRING(0 2,1 1,1 0,1 1,2 2))
                which is overlaps itself, it's invalid. After use this function, it will be
                MULTILINESTRING ((0 2, 1 1, 2 2), (1 1, 1 0))
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetFirstGeometryType">
            <summary>
            Get The shape type from the first record.
            </summary>
            <returns>The shape type of the first record.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.ExecuteNonQueryCore(System.String)">
            <summary>Executes a SQL statement against a connection object.</summary>
            <returns>The number of rows affected.</returns>
            <remarks>
            	You can use ExecuteNonQuery to perform catalog
                operations (for example, querying the structure of a database or creating database
                objects such as tables), or to change the data in a database by executing UPDATE,
                INSERT, or DELETE statements.
            	Although ExecuteNonQuery does not return any
                rows, any output parameters or return values mapped to parameters are populated
                with data.
            	For UPDATE, INSERT, and DELETE statements, the return value is the number of
                rows affected by the command.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.ExecuteQueryCore(System.String)">
            <summary>
            Executes the query and returns the result returned by the query.
            </summary>
            <returns>The result set in the format of dataTable.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            reaquires less code than use the ExcuteQuery method and performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.ExecuteScalarCore(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            reaquires less code than use the ExcuteQuery method and performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this abstract method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CloseCore">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the abstract core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MsSqlFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this if you want an
            efficient version of this method then we high suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType">
            <summary>
            This property gets the spatial data type in the
            <strong>MsSql2008FeatureSource</strong>.
            </summary>
            <remarks>
            	<para>In SQL Server 2008 there are two new data types for storing spatial
                information: GeometryType and GeographyType.</para>
            	<para>The Geometry data type supports a flat 2D surface with XY coordinates for
                points. Points can be lines , on line string and mark edges of polygons.</para>
            	<para>The Geography data type uses the same methods but the data type reflects the
                fact that we live on a curved 2D surface popularly known as the earth.</para>
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType.Geometry">
            <summary>
            The GeometryType supported in SQL Server2008.
            </summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.MsSqlSpatialDataType.Geography">
            <summary>
            The GeographyType supported in SQL Server2008.
            </summary>
        </member>
    </members>
</doc>
