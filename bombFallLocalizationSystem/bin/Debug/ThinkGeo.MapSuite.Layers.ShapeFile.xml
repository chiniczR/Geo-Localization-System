<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ThinkGeo.MapSuite.Layers.ShapeFile</name>
    </assembly>
    <members>
        <member name="T:ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the BuildingIndex
            event in ShapeFileFeatureSource class.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs.RecordCount">
            <summary>
            Gets the total record count to build rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs.CurrentRecordIndex">
            <summary>
            Gets the current record index for building rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs.CurrentFeature">
            <summary>
            Gets the current feature for building rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs.StartProcessTime">
            <summary>
            Gets the starting process time for building the index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs.Cancel">
            <summary>
            Gets or sets to see if we need to cancel the building index of current record.
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource">
            <summary>This class represents a FeatureSource backed by multiple ESRI Shape Files.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.#ctor">
            <summary>This is the default constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor then you need to set
            the required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor then you need to set
            the required properties manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.#ctor(System.String)">
             <summary>This is the constructor for the class.</summary>
             <overloads>
             This is the  constructor for this class.
             </overloads>
             <returns>None</returns>
             <remarks>
             This is the constructor for this class. You can pass in a
             multipleShapeFilePattern like C:\MapData\??lka.shp to use all the shp files in the
             C:\MapData\ folder with a five letters as its file name without extentsion, the last three
            should be "lka". And also you can use c:\MapData\USRoad??.shp as the parameter to
             use all the file which the file name begin with "USRoad" and end with any 2 character
             shape file; like "USRoadA1.shap" or "USRoad_1.shp".
             </remarks>
             <param name="multipleShapeFilePattern">
             This parameter represents the shape file path pattern. The format of it should be
             "C:\MapData\USRoad??.Shp".
             </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.#ctor(System.String,System.String)">
             <summary>This is the constructor for the class.</summary>
             <overloads>
             This is the constructor for this class. It allows you passing the shape file
             pattern and index file pattern to create this class.
             </overloads>
             <returns>None</returns>
             <remarks>
             This is the constructor for this class. You can pass in a
             multipleShapeFilePattern like C:\MapData\??lka.shp to use all the shp files in the
             C:\MapData\ folder with a five letters as its file name without extentsion, the last three
            should be "lka". And also you can use c:\MapData\USRoad??.shp as the parameter to
             use all the file which the file name begin with "USRoad" and end with any 2 character
             shape file; like "USRoadA1.shap" or "USRoad_1.shp".
             </remarks>
             <param name="multipleShapeFilePattern">
             This parameter represents the shape file path pattern. The format of it should be
             "C:\MapData\USRoad??.Shp".
             </param>
             <param name="indexFilePattern">
             This parameter represents the index file path pattern. The format of it should be
             "C:\MapData\USRoad??.idx".
             </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the  constructor for this class.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the constructor for this class. You can pass in a group of shapes and its corresponding indexs
            like string[] shapeFiles = new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" };
                 string[] indexFiles = new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" };
            In this way, the MultipleShapeFileFeatureSource will construct from the passing 2 shapes.
            </remarks>
            <param name="shapeFiles">
            This parameter represents the shape files to construct the ShapeFileFeatureSource. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="indexes">
            This parameter represents the shape files to construct the ShapeFileFeatureSource. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.MultipleShapeFilePattern">
            <summary>This parameter gets and sets the shape file pattern.</summary>
            <value>This parameter gets and sets the shape file pattern.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.IndexFilePattern">
            <summary>This parameter gets and sets the index file pattern.</summary>
            <value>This parameter gets and sets the index file pattern.</value>
            <remarks>None.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.Encoding">
            <summary>
            This property get and set the encoding information for the dbf.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetShapePathFilenames">
            <summary>
            This method gets all the shape's path and filenames are using in this class based
            on the pass in MultipleShapeFilePattern.
            </summary>
            <returns>
            This method gets all the shape's path and filenames are using in this class based
            on the pass in MultipleShapeFilePattern.
            </returns>
            <remarks>
            	<para>This method gets all the shape's path and filenames are using in this class
                based on the pass in MultipleShapeFilePattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the shape file in folder
                "C:\MapData\" which filename only has 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetIndexPathFilenames">
            <remarks>
            	<para>This method gets all the index's path and filenames are using in this class
                based on the pass in MultipleIndexFilePattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.idx" as the MultipleIndexFilePattern,
                this method will return a collection which contains all the index file in folder
                "C:\MapData\" which filename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.idx" as the
                MultipleIndexFilePattern, this method will return a collection which contains all
                the index file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.idx or USRoad_A.idx. By the way, the file named
                <strong>A</strong>USRoadA1.idx and USRoadA1<strong>A</strong>.idx will NOT included
                in the returning collection.</para>
            </remarks>
            <summary>
            This method gets all the index's path and filenames are using in this class based
            on the pass in MultipleIndexFilePattern.
            </summary>
            <returns>
            This method gets all the index's path and filenames are using in this class based
            on the pass in MultipleIndexFilePattern.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which filename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter; and the spatial index file name will be in the
            indexFilePattern.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
            <param name="indexFilePattern">
            	<para>This parameter reprensents the dindex file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.idx" as the MultipleIndexFilePattern,
                this method will return a collection which contains all the .idx file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.idx" as the
                MultipleIndexFilePattern, this method will return a collection which contains all
                the index file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.idx or USRoad_A.idx.</para>
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method build spatial index for a passed group of shape files.</summary>
            <overloads>
            This method build spatial index for a passed group of shape files based on the
            pass in parameter; and the spatial index file name will be in the
            indexFilePattern.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            	<para>This parameter reprensents the shape file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.shp" as the MultipleShapeFilePattern,
                this method will return a collection which contains all the .shp file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.shp" as the
                MultipleShapeFilePattern, this method will return a collection which contains all
                the shape file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.shp or USRoad_A.shp.</para>
            </param>
            <param name="indexFilePattern">
            	<para>This parameter reprensents the dindex file's name in the pattern.</para>
            	<para>For example:</para>
            	<para>If you pass in the path "C:\MapData\???.idx" as the MultipleIndexFilePattern,
                this method will return a collection which contains all the .idx file in folder
                "C:\MapData\" which finename has only 3 characters.</para>
            	<para>If you pass in the path "C:\MapData\USRoad??.idx" as the
                MultipleIndexFilePattern, this method will return a collection which contains all
                the index file which begin with "USRoad" and end with and 2 characters in folder
                "C:\MapData\"; like USRoadA1.idx or USRoad_A.idx.</para>
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String,System.String,System.String)">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the shape file name pattern that you want to build an index for. </param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="indexFilename">This parameter specifies the index file name.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the shape file name pattern that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String[],System.String[])">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.BuildIndex(System.String[],System.String[],ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build spatial index for a passed group of shape files.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
            <param name="buildIndexMode">
            This parameter determines whether the index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the virtual core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this virtual method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.CloseCore">
            <summary>
            This method closes the FeatureSource and releases any resources it was
            using.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this if you want an
            efficient version of this method then we high suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the ids we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the boundingBox we will throw an ArgumentNullException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetFeaturesWithinDistanceOfCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,ThinkGeo.MapSuite.Shapes.DistanceUnit,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </summary>
            <returns>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape.
            </returns>
            <remarks>
            This method returns a collection of InternalFeatures that are within a certain distance
            of the TargetShape. It is important to note that the TargetShape and the FeatureSource
            use the same unit such as feet or meters. If they do not then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live then
            the results will include any transaction Feature that applies.<br/>
            	<br/>
            The implementation we provided create a bounding box around the TargetShape using the
            distance supplied and then queries the features inside of it. This may not the most
            efficient method for this operation. If you underlying data provider exposes a more
            efficient way we recommend you override the Core version of this method and implement
            it.<br/>
            	<br/>
            The default implementation of GetFeaturesWithinDistanceOfCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. We
            recommend when you override GetFeaturesInsideBoundingBoxCore method that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">The shape you wish to find InternalFeatures within a distance of.</param>
            <param name="unitOfData">
            This parameter is the unit of data that the FeatureSource and TargetShape are
            in.
            </param>
            <param name="distanceUnit">
            This parameter specifies the unit of the distance parameter such as feet, miles
            or kilometers etc.
            </param>
            <param name="distance">
            This parameter specifies the distance in which to find InternalFeatures around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a unitOfData that is not defined it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a distanceUnit that is not defined it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureSource.GetFeaturesNearestToCore(ThinkGeo.MapSuite.Shapes.BaseShape,ThinkGeo.MapSuite.GeographyUnit,System.Int32,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </summary>
            <returns>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape.
            </returns>
            <remarks>
            This method returns a user defined number of InternalFeatures that are closest to the
            TargetShape. It is important to note that the TargetShape and the FeatureSource use the
            same unit such as feet or meters. If they do not then the results will not be
            predictable or correct. If there is a current transaction and it is marked as live then
            the results will include any transaction Feature that applies.<br/>
            	<br/>
            The implementation we provided create a small bounding box around the TargetShape and
            then queries the features inside of it. If we reach the number of items to find then we
            measure the returned InternalFeatures to find the nearest. If we do not find enough records we
            scale up the bounding box and try again. As you can see this is not the most efficient
            method. If you underlying data provider exposes a more efficient way we recommend you
            override the Core version of this method and implement it.<br/>
            	<br/>
            The default implementation of GetFeaturesNearestCore uses the
            GetFeaturesInsideBoundingBoxCore method for speed. We strongly recommend that you
            provide your own implementation for this method that will be more efficient. We
            recommend when you override GetFeaturesInsideBoundingBoxCore method that you use any
            spatial indexes you have at your disposal to make this method as fast as
            possible.
            </remarks>
            <param name="targetShape">This parameter is the shape you should to find close InternalFeatures to.</param>
            <param name="unitOfData">
            This parameter is the unit of what the TargetShape and the FeatureSource is in
            such as feet, meters etc.
            </param>
            <param name="maxItemsToFind">
            This parameter defines how many close InternalFeatures to find around the
            TargetShape.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the targetShape we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentNullException" caption="ArgumentNullException">If you pass a null as the returningColumnNames we will throw an ArgumentNullException.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException" caption="ArgumentOutOfRangeException">If you pass in a maxItemsToFind that is not greater than 0 it will throw a ArgumentOutOfRangeException.</exception>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">If you pass in a targetShape which is invalid we will throw an ArgumentException.</exception>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs">
            <summary>
            This class represents the parameters passed in through the BuildingIndex
            event in ShapeFileFeatureSource class.
            </summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.#ctor">
            <summary>
            This is the default constructor of the event args.
            </summary>
            <remarks>If you use this constructor, you have to set the properties manually.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.#ctor(System.Int32,System.Int32,ThinkGeo.MapSuite.Shapes.Feature,System.DateTime,System.Boolean)">
            <summary>
            This is the constructor of the event args by passing the desired parameters.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.RecordCount">
            <summary>
            Gets the total record count to build rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.CurrentRecordIndex">
            <summary>
            Gets the current record index for building rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.CurrentFeature">
            <summary>
            Gets the current feature for building rTree index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.StartProcessTime">
            <summary>
            Gets the starting process time for building the index.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.RebuildingShapeFileFeatureSourceEventArgs.Cancel">
            <summary>
            Gets or sets to see if we need to cancel the building index of current record.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFile.IsPointInRing(ThinkGeo.MapSuite.Shapes.Vertex,ThinkGeo.MapSuite.Shapes.RingShape)">
            <summary>
            Test whether a point lies inside a ring.
            The ring may be oriented in either direction.
            If the point lies on the ring boundary the result of this method is unspecified.
            This algorithm does not attempt to first check the point against the envelope
            of the ring.
            </summary>
            <param name="p">Point to check for ring inclusion.</param>
            <param name="ring">Assumed to have first point identical to last point.</param>
            <returns><c>true</c> if p is inside ring.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileBoundingBox.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileBoundingBox.MergeBoundingBox(ThinkGeo.MapSuite.Layers.ShapeFileBoundingBox)">
            <summary>
            merge the input Bounding Box, store the result
            </summary>
            <param name="targetBox">the input BoundingBox to be merged</param>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource">
            <summary>This class represents a FeatureSource backed by ESRI a Shape File.</summary>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.#ctor">
            <summary>This is the class constructor.</summary>
            <overloads>
            This is the default constructor and requires you to set the properties after you
            create the class.
            </overloads>
            <remarks>None</remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.#ctor(System.String)">
            <summary>This is the class constructor.</summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <overloads>
            This constructor allows you to pass in a path and file name to the shape
            file.
            </overloads>
            <param name="shapePathFilename">This parameter represents the path and file name to the .shp file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.#ctor(System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>This is the class constructor.</summary>
            <overloads>
            This constructor allows you to pass in a path, file name and files access mode to
            the shape file.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter represents the path and file name to the .shp file.</param>
            <param name="readWriteMode">This parameters represents the mode that we will open the file in.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify the shape file and the index file to
            use.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to specify the shape file and the index file to use.
            In some cases you may want to build custom index files or want the index file to have a
            different name that the shape file.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file name you want to load.</param>
            <param name="indexPathFilename">This parameter is the index file you want to use.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to specify the shape file and the index file to use
            along with the read and write level.
            </overloads>
            <returns>None</returns>
            <remarks>
            This constructor allows you to specify the shape file and the index file to use.
            In some cases you may want to build custom index files or want the index file to have a
            different name that the shape file. It also allows you to specify is you want to open
            the files for read or read and write. You will need to open the file for read and write
            if you plan on doing any editing to the files.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file name you want to load.</param>
            <param name="indexPathFilename">This parameter is the index file you want to use.</param>
            <param name="readWriteMode">
            This parameter reflects if you want to open shape file and index for read or read
            write mode.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode,System.Text.Encoding)">
             <summary>This is a constructor for the class.</summary>
             <overloads>
             This constructor allows you to specify the shape file and the index file to use
             along with the read and write level.
             </overloads>
             <returns>None</returns>
             <remarks>
             This constructor allows you to specify the shape file and the index file to use.
             In some cases you may want to build custom index files or want the index file to have a
             different name that the shape file. It also allows you to specify is you want to open
             the files for read or read and write. You will need to open the file for read and write
             if you plan on doing any editing to the files.
             </remarks>
             <param name="shapePathFilename">This parameter is the shape file name you want to load.</param>
             <param name="indexPathFilename">This parameter is the index file you want to use.</param>
             <param name="readWriteMode">
             This parameter reflects if you want to open shape file and index for read or read
             write mode.
             </param>
            <param name="encoding">The encoding to read and write the dbf file.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.ShapePathFilename">
            <summary>This property returns the path and file of the shape file you want to use.</summary>
            <decimalDegreesValue>This property returns the path and file of the shape file you want to use.</decimalDegreesValue>
            <remarks>
            When you specify the path and file name it should be in the correct format as
            such however the file does not need to exists on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists then we will attempt to use it. If we cannot find it then we will raise the
            SteamLoading event and allow you to supply the stream. For example you can pass in
            "C:\NotARealPath\File1.shp" which does not exists on the file system. When we raise the
            event for you to supply a stream we will pass to you the path and file name for you to
            differentiate the files.
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid FilePathName structure will thrown an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.IndexPathFilename">
            <summary>
            This property gets and sets the path and file of the index you want to
            use.
            </summary>
            <remarks>
            When you specify the path and file name it should be in the correct format as
            such however the file does not need to exists on the file system. This is to allow us
            to accept streams supplied by the developer at runtime. If you choose to provide a file
            that exists then we will attempt to use it. If we cannot find it then we will raise the
            SteamLoading event and allow you to supply the stream. For example you can pass in
            "C:\NotARealPath\File1.idx" which does not exists on the file system. When we raise the
            event for you to supply a stream we will pass to you the path and file name for you to
            differentiate the files.
            </remarks>
            <decimalDegreesValue>This property returns the path and file of the index you want to use.</decimalDegreesValue>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.IsEditable">
            <summary>This property returns if the FeatureSource allows edits or is read only.</summary>
            <decimalDegreesValue>
            This property returns if the FeatureSource allows edits or is read only. The
            property returns true if the FeatureSource allows edits and false if the FeatureSource
            is read only.
            </decimalDegreesValue>
            <remarks>
            	<para>This property is useful to check if a specific FeatureSource accepts editing.
                If you call the BeginTransaction and this property is false then an exception will
                be raised.<br/>
            		<br/>
                For developers who are creating or extending a FeatureSource it is expected that
                you override this virtual method if the new FeatureSource you are creating allows
                edits. By default the decimalDegreesValue if false meaning that if you want to allow edits you
                must override this method and return true.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CanExecuteSqlQueryCore">
            <summary>
            This property specifies the FeatureSource can excute sql query or not.
            If it is false, then it will throw exception when called the APIs:ExecuteScalar,ExecuteNonQuery,ExecuteQuery
            This orverides will make it true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.UsingSpatialIndex">
            <summary>
            This property gets the shape file feature source with index or not.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.RequireIndex">
            <summary>
            This property gets and sets the requirement of index when reading data. The default value is true.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.Encoding">
            <summary>
            This property get and set the encoding information for the dbf.
            </summary>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.StreamLoading">
            <summary>
            This event allows you to pass in your own stream to represent the
            files.
            </summary>
            <remarks>
            If you choose you can pass in your own stream to represent the file. The
            stream can come from a variety of places such as isolated storage, a compressed file,
            and encrypted stream. When the Image is finished with the stream it will dispose
            of it so be sure to keep this in mind when passing the stream in. If you do not pass in
            a alternate stream the class will attempt to load the file from the file system
            using the PathFilename property.
            </remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildingIndex">
             <summary>
             This event will be fired each time a record was built the rtree index.
            
             You can choose to use this event to build the build index progess bar.
             </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.OnStreamLoading(ThinkGeo.MapSuite.Layers.StreamLoadingEventArgs)">
            <summary>This method allows you to raise the StreamLoading event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the StreamLoading event. Normally events are not
            accessible to derived classes so we exposed a way to raise the event is necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the StreamLoading
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.OnBuildingIndex(ThinkGeo.MapSuite.Layers.BuildingIndexShapeFileFeatureSourceEventArgs)">
            <summary>This method allows you to raise the BuildingIndex event.</summary>
            <returns>None</returns>
            <remarks>
            This method allows you to raise the BuildingIndex event. Normally events are not
            accessible to derived classes so we exposed a way to raise the event is necessary
            through this protected method.
            </remarks>
            <param name="e">
            This parameter represents the event arguments you want to raise the BuildingIndex
            event with.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.Rebuild(System.String)">
            <summary>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file. When we do editing we have optimized the updates so that we do not need to
            rebuild the entire shape file. This leads to the shape file being out of order which
            may cause it not to open in other tools. One optimization is if you update a record
            instead of rebuilding a new shape file we mark the old record as null and add the
            edited record at the end of the shape file. This greatly increases the speed of
            committing shape file changes but will over time unorder the shape file. In addition we
            do a delete the DBF file will simply mark the record deleted and not compact the space.
            Rebuilding the shape file will correctly order the SPX and SHX along with compacting
            the DBF file and rebuild any index with the same any of the shape file if it
            exists.<br/>
            	<br/>
            Note that if you have build custom index files where the name of the index differs from
            that of the shape file you will need to rebuild those manually using the BuildIndex
            methods.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file you want to rebuild.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String)">
            <summary>
            This method build a spatial index for the shape file which increases access
            speed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. It will not do a rebuild if there is an existing
            index.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. It will not do a rebuild if there is an existing
            index.
            </remarks>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access
            speed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access
            speed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
            <param name="indexPathFilename">
            This parameter specifies the index file name.
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regex expression to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode,System.Text.Encoding)">
            <summary>
            This method build a spatial index for the shape file which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression,besides this, this overloads will pass in a target index projection.
            You can also specify if you want to rebuild an existing index file.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name and only build Index for those records
            satisfied the regularExpression. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">This parameter is the shape file name and path that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
            <param name="columnName"> The columnName to be used to get the value to match the regex expression.</param>
            <param name="regularExpression">This parameter specifies the regular expression pattern to filter out thoese records to build index with.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
            <param name="encoding"> This parameter determines the Enconding system used in the dbf, and this will be used if the dbf is encoded in a different encoding with default.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String)">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String,ThinkGeo.MapSuite.Shapes.Projection)">
            <summary>
            This method build a spatial index for a passed group of featurs using the specified projection which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String,ThinkGeo.MapSuite.Shapes.Projection,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for a passed group of featurs which increases access speed.
            </summary>
            <overloads>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </overloads>
            <remarks>
            This overload builds an index file with the specified index file name for a group of passed in features.
            </remarks>
            <returns>None</returns>
            <param name="features">This parameter specifies the target group of features that you want to build an index for. </param>
            <param name="indexPathFilename">This parameter specifies the index file name.</param>
            <param name="buildIndexMode">This parameter determines what will happen if there is an existing index file.</param>
            <param name="projection"> This parameter specifies the projection used to build index file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CreateShapeFile(ThinkGeo.MapSuite.Layers.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.DbfColumn})">
            <summary>
            Static API to create a new shape file.
            </summary>
            <param name="shapeType">This parameter specifies the the shape file type for the target shape file.</param>
            <param name="pathFilename">This parameter specifies the shape file name for the target shape file.</param>
            <param name="databaseColumns">This parameter specifies the dbf column information for the target shape file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CreateShapeFile(ThinkGeo.MapSuite.Layers.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.DbfColumn},System.Text.Encoding)">
            <summary>
            Static API to create a new shape file.
            </summary>
            <param name="shapeType">This parameter specifies the the shape file type for the target shape file.</param>
            <param name="pathFilename">This parameter specifies the shape file name for the target shape file.</param>
            <param name="databaseColumns">This parameter specifies the dbf column information for the target shape file.</param>
            <param name="encoding">This parameter specifies the dbf encoding infromation for the target shape file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CreateShapeFile(ThinkGeo.MapSuite.Layers.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.DbfColumn},System.Text.Encoding,ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            Static API to create a new shape file.
            </summary>
            <param name="shapeType">This parameter specifies the the shape file type for the target shape file.</param>
            <param name="pathFilename">This parameter specifies the shape file name for the target shape file.</param>
            <param name="databaseColumns">This parameter specifies the dbf column information for the target shape file.</param>
            <param name="encoding">This parameter specifies the dbf encoding infromation for the target shape file.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
            <remarks>Exception will be thown when the target shape file exist while the override mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDbfColumns">
            <summary>
            Get the dbf columns out from the shape file featureSource.
            </summary>
            <returns>The dbfColumns in the shape file FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CloneShapeFileStructure(System.String,System.String)">
            <summary>
            Clone out the structure from the source shape file to the target shape file. After cloning the structure,
            the targetShapeFile has the same type and same dbf columns with the source shape file but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source shape file to be cloned.</param>
            <param name="targetShapePathFilename">The target shape file with same structure with the source one after the structure cloned.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            Clone out the structure from the source shape file to the target shape file. After cloning the structure,
            the targetShapeFile has the same type and same dbf columns with the source shape file but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source shape file to be cloned.</param>
            <param name="targetShapePathFilename">The target shape file with same structure with the source one after the structure cloned.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
            <remarks>Exception will be thown when the target shape file not extis while the override mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Layers.OverwriteMode,System.Text.Encoding)">
            <summary>
            Clone out the structure from the source shape file to the target shape file. After cloning the structure,
            the targetShapeFile has the same type and same dbf columns with the source shape file but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source shape file to be cloned.</param>
            <param name="targetShapePathFilename">The target shape file with same structure with the source one after the structure cloned.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
            <param name="encoding"> This parameter specifies the encoding information in the source shape file.</param>
            <remarks>Exception will be thown when the target shape file not extis while the override mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.Validate">
            <summary>
            This method checks all features in a shapefile is supported by Mapsuite or not.
            </summary>
            <returns>A dictionary which contains all the unsupported features. The key is the Indexs which
            failed to pass the check, the value contains the reason for its failure.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnBoolean(System.String)">
            <summary>
            This method adds a new Boolean column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnDate(System.String)">
            <summary>
            This method adds a new Date column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnDouble(System.String,System.Int32,System.Int32)">
            <summary>
            This method adds a new Double column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="totalLength">
            This is the total length of the field including both the digits to the left and
            right of the decimal point.
            </param>
            <param name="precisionLength">
            This parameter specifies how many digits after the decimal point you need to
            support.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnInteger(System.String,System.Int32)">
            <summary>
            This method adds a new Integer column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="length">This parameter specifies the length of the integer.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnMemo(System.String)">
            <summary>
            This method adds a new Memo column to the DBF file associated with the shape
            file.
            </summary>
            <remarks>
            This method adds a new Memo column to the DBF file associated with the shape
            file.<br/>
            	<br/>
            Internally the DBF holds an integer column that is a pointer to the data in the memo
            file. The pointer is measured in 512 byte chunks. Our default decimalDegreesValue for the size of the
            pointer column is 10 which means you can have 9,999,999,999 pointers to the 512 byte
            blocks. The ramification of this is that if you have more than this many records and
            each record uses more then 512 bytes as part of its memo then there will not be enough
            space for storage. If you have special needs for this please use the other overload
            that allows you to specify the number of digits you can use for the pointer.
            </remarks>
            <returns>None</returns>
            <overloads>
            This constructor allows you to specify the column name and uses 10 for the
            memoPointerLength.
            </overloads>
            <param name="columnName">This parameter is the column you want to add.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnMemo(System.String,System.Int32)">
            <remarks>
            	<para>This method adds a new Memo column to the DBF file associated with the shape
                file.<br/>
            		<br/>
                Internally the DBF holds an integer column that is a pointer to the data in the
                memo file. The pointer is measured in 512 byte chunks. Our default decimalDegreesValue for the
                size of the pointer column is 10 which means you can have 9,999,999,999 pointers to
                the 512 byte blocks. The ramification of this is that if you have more than this
                many records and each record uses more than 512 bytes as part of its memo then
                there will not be enough space for storage. Conversely if you know you have few
                records then you can decrease this number. A good rule of thumb is to multiply the
                number of records by the number of 512 byte chunks you expect each record to use
                and then get the resulting number of digits resulting for the multiplication.<br/>
            		<br/>
                Example<br/>
            		<br/>
                You have 1,000,000 records and expect to have 4K, 8 chunks of 512 bytes, of memo
                data for each record. This means you will use multiple 1,000,000 * 8 which is
                8,000,000 and then total the number of digits which in this case is 7. Assuming the
                numbers above a length of 7 will support your needs.</para>
            </remarks>
            <summary>
            This method adds a new Memo column to the DBF file associated with the shape
            file.
            </summary>
            <overloads>
            This constructor allows you to specify the column name and the
            memoPointerLength.
            </overloads>
            <returns>None</returns>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="memoValueLength">
            This parameter is the number of digits you need to hold the pointers to the data
            in the memo file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.AddColumnString(System.String,System.Int32)">
            <summary>
            This method adds a new String column to the DBF file associated with the shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>
            This method adds a new String column to the DBF file associated with the shape
            file.
            </remarks>
            <param name="columnName">This parameter is the column you want to add.</param>
            <param name="length">This parameter is the number of characters that the string can hold.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.String,System.String)">
            <summary>
            This method gets data directly from the DBF file associated with the shape
            file.
            </summary>
            <overloads>This overload allows you to passing an Id and a column name.</overloads>
            <returns>
            This method gets data directly from the DBF file associated with the shape
            file.
            </returns>
            <remarks>
            This method gets data directly from the DBF file associated with the shape file.
            When you specify the Id and column name it will get the decimalDegreesValue from the DBF.
            </remarks>
            <param name="id">This parameter is the Id for the Feature you want to find.</param>
            <param name="columnName">This parameter is the column name you want to return.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.String)">
            <summary>
            This method gets data directly from the DBF file associated with the shape
            file.
            </summary>
            <overloads>
            This overload allows you to pass in an Id and return all of the DBF column for
            that Feature.
            </overloads>
            <returns>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified.
            </returns>
            <remarks>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="id">This parameter is the Id of the Feature you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in an Id and specified returning columns for that Feature.
            </overloads>
            <returns>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified.
            </returns>
            <remarks>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="id">This parameter is the Id of the Feature you want.</param>
            <param name="returningColumnNames"> This parameter is the returning columns specified for the returning data.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.String,ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in an Id and specified returning columns for that Feature.
            </overloads>
            <returns>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified.
            </returns>
            <remarks>
            This method returns a dictionary holding all of the values from the DBF for the
            Id you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="id">This parameter is the Id of the Feature you want.</param>
            <param name="returningColumnNamesType"> This parameter is the returningColumnType specified for the returning data.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method gets data directly from the DBF file associated with the shape
            file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and return all of the DBF column for
            those Features.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and a returning columnName.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
            <param name="columnName"> This parameter is the returning columnName of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and a returning columnNames.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
            <param name="columnNames"> This parameter is the returning columnNames of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetDataFromDbf(System.Collections.Generic.IEnumerable{System.String},ThinkGeo.MapSuite.Shapes.ReturningColumnsType)">
            <summary>
            This method gets data directly from the DBF file associated with the shape file.
            </summary>
            <overloads>
            This overload allows you to pass in a group of Ids and a returning columnNames.
            </overloads>
            <returns>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified.
            </returns>
            <remarks>
            This method returns a collection of dictionary holding all of the values from the DBF for the
            Ids you specified. In the dictionary the key is the column name and values are the
            values from the DBF.
            </remarks>
            <param name="ids">This parameter is the Ids of the Features you want.</param>
            <param name="returningColumnNamesType"> This parameter is the returning column type of the Features you want.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.UpdateDbfData(System.String,System.String,System.String)">
            <summary>This method updates data in the DBF file associated with the shape file.</summary>
            <overloads>This overload allows you to pass in the Id, column name and the decimalDegreesValue.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="id">This parameter is the Id of the feature you want to update.</param>
            <param name="columnName">This parameter is the column name you want to update.</param>
            <param name="value">This parameter is the decimalDegreesValue you want to set.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.UpdateDbfData(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>This method updates data in the DBF file associated with the shape file.</summary>
            <overloads>This overload allows you to pass in the Id, columnNames and the values.</overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="id">This parameter is the Id of the feature you want to update.</param>
            <param name="columnNames">This parameter is the columnNames you want to update.</param>
            <param name="values">This parameter is the target values you want to set.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.ExecuteNonQueryCore(System.String)">
            <summary>
            This method executes a SQL query that does returns only a result of the number of
            record affected.
            </summary>
            <returns>This method returns the number of record affected by the SQL query.</returns>
            <remarks>
            This method executes a SQL query that does returns only a result of the number of
            record affected. Note that for the table name in the SQL query you need to use the
            shape file name without the SHP extension.
            </remarks>
            <param name="sqlStatement">This parameter is the SQL statement to execute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.ExecuteScalarCore(System.String)">
            <summary>
            Executes the query and returns the first column of the first row in the result
            set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set.</returns>
            <remarks>
            Use the ExcuteScalar method to retrieve a single value from the database. This
            reaquires less code than use the ExcuteQuery method and performing the operations
            necessary to generate the single value using the data.
            </remarks>
            <param name="sqlStatement">The sqlStatement to be excuted.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.ExecuteQueryCore(System.String)">
            <summary>This method returns a DataTable based on the SQL statement you provided.</summary>
            <returns>
            This method returns a DataTable based on the SQL statement you provided. Note
            that for the table name in the SQL query you need to use the shape file name without
            the SHP extension.
            </returns>
            <remarks>This method returns a DataTable based on the SQL statement you provided.</remarks>
            <param name="sqlStatement">This parameter is the SQL state you want to execute.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetShapeFileType">
            <summary>
            Get shape file type for the shape file featureSource.
            </summary>
            <returns>The shapeFileType for the ShapeFileFeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildRecordIdMode)">
            <summary>
            Static API used to build RecordId, the id should start from 0 by default.
            </summary>
            <param name="shapeFilename">The target shape file name to build record id based on.</param>
            <param name="fieldname">The fild name for the record id.</param>
            <param name="rebuildNeeded">The build record id mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildRecordIdMode,System.Int32)">
            <summary>
            Static API used to build RecordId from the specified starting id number.
            </summary>
            <param name="shapeFilename">The target shape file name to build record id based on.</param>
            <param name="fieldname">The fild name for the record id.</param>
            <param name="rebuildNeeded">The build record id mode.</param>
            <param name="startNumber">The starting id number of the record id.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildRecordIdMode,System.Int32,System.Text.Encoding)">
            <summary>
            Static API used to build RecordId from the specified starting id number.
            </summary>
            <param name="shapeFilename">The target shape file name to build record id based on.</param>
            <param name="fieldname">The fild name for the record id.</param>
            <param name="rebuildNeeded">The build record id mode.</param>
            <param name="startNumber">The starting id number of the record id.</param>
            <param name="encoding"> This parameter specified the encoding information in dbf.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.SaveToProjection(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            This API provide a easy way to project features in a shape file into another projection and save it to shape file.
            </summary>
            <param name="sourceShapeFile">This parameter specifies the source shape file to be projected.</param>
            <param name="targetShapeFile">This parameter specifies the target shape file to be saved for the projected features. </param>
            <param name="projection">This parameter is the projection to project the source shape file to target shape file. The source
            Shape file should be in the FromProjection of the Projection prameter, and the targetShapeFile will be in the ToProjection
            of the Projection.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.OpenCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has already been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <remarks>
            This protected virtual method is called from the concreate public method Open.
            The open method play an important role as it is responsible for initializing the
            FeatureSource. Most methods on the FeatureSource will throw an exception if the state
            of the FeatureSource is not opened. When the map draws each layer it will open the
            FeatureSource as one of its first steps, then after it is finished drawing with that
            layer it will close it. In this way we are sure to release all resources used by the
            FeatureSource.<br/>
            	<br/>
            When implementing this abstract method consider opening files for file based source,
            connecting to databases in the database based sources and so on. You will get a chance
            to close these in the Close method of the FeatureSource.
            </remarks>
            <returns>None</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CloseCore">
            <summary>
            This method opens the FeatureSource so that it is initialized and ready to
            use.
            </summary>
            <returns>None</returns>
            <remarks>
            This protected virtual method is called from the concreate public method Close.
            The close method plays an important role in the life cycle of the FeatureSource. It may
            be called after drawing to release any memory and other resources that were allocated
            since the Open method was called.<br/>
            	<br/>
            It is recommended that if you override this method that you take the following things
            into account. This method may be called multiple times so we suggest you write the so
            that that a call to a closed FeatureSource is ignored and does not generate an error.
            We also suggest that in the close you free all resources that have been opened.
            Remember that the object will not be destroyed but will be re-opened possibly in the
            near future.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.CommitTransactionCore(ThinkGeo.MapSuite.Layers.TransactionBuffer)">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which is not in transaction it will throw an InvalidOperationException.</exception>
            <summary>
            This method will commit the existing transaction to its underlying source of
            data.
            </summary>
            <remarks>
            	<para>This method will commit the existing transaction to its underlying source of
                data. It will pass back the results of how the commit went to include any error
                received. If you are implementing your own FeatureSource then this is one of the
                crucial methods you must create. It should be fairly straight forward that you will
                loop through the transaction buffer and add, edit or delete the InternalFeatures in your
                underlying data source. Remember to build and pass back the TransactionResult class
                so that users of your FeatureSource can respond to failures you may encounter
                committing the InternalFeatures. We will handle the end of the transaction and also the
                cleanup of the transaction buffer. Your task will be to commit the records and
                produce a TransactionResult return.</para>
            	<para>The Transaction System</para>
            	<para>The transaction system of a FeatureSource sits on top of the inherited
                implementation of any specific source such as Oracle Spatial or Shape files. In
                this way it functions the same way for every FeatureSource. You start by calling
                the BeginTransaction. This allocates a collection of in memory change buffers that
                are used to store changes until you commit the transaction. So for example when you
                call the Add, Delete or Update method the changes to the feature are stored in
                memory only. If for any reason you choose to abandon the transaction you can call
                RollbackTransaction at any time and the in memory buffer will be deleted and the
                changes will be lost. When you are ready to commit the transaction you call the
                CommitTransaction and the collections of changes are then passed to the
                CommitTransactionCore method and the implementer of the specific FeatureSource is
                responsible for integrating your changes into the underlying FeatureSource. By
                default the IsLiveTransaction property is set to false which means that until you
                commit the changes the FeatureSource API will not reflect any changes that are in
                the temporary editing buffer.</para>
            	<para>In the case where the IsLiveTransaction is set to true then things function
                slightly differently. The live transaction concept means that all of the
                modification you perform during a transaction are live from the standpoint of the
                querying methods on the object.</para>
            	<para>To setup an example imagine that you have a FeatureSource that has 10 records
                in it. Next you begin a transaction and then call GetAllFeatures, the result would
                be 10 records. After that you call a delete on one of the records and call the
                GetAllFeatures again, this time you only get nine records. You receive nine records
                even though the transaction has not yet been committed. In the same sense you could
                have added a new record or modified an existing one and those changes are
                considered live though not committed.</para>
            	<para>In the case where you modify records such as expanding the size of a polygon
                those changes as well are reflected. So for example you expand a polygon by
                doubling its size and then do a spatial query that would not normally return the
                smaller record but would return the larger records, in this case the larger record
                is returned. You can set this property to be false as well in which case all of the
                spatial related methods would ignore anything that is currently in the transaction
                buffer waiting to be committed. In this case only after committing the transaction
                would the FeatureSource reflect the changes.</para>
            </remarks>
            <returns>
            The return decimalDegreesValue of this method is a TransactionResult class which gives you the
            status of the transaction you just committed. It includes how many of the updates,
            adds, and deletes were successful and any error that were encountered during the
            committing of the transaction.
            </returns>
            <param name="transactions">
            This parameter encapsulates all of the adds, edits and deleted that make up the
            transaction. You will use this data to write the changes to your underlying data
            source.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetAllFeaturesCore(System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns all of the InternalFeatures in the FeatureSource.</summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures in the
            FeatureSource.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures in the FeatureSource. You will not need
            to consider anything about pending transactions as this will be handled in the non Core
            version of the method.<br/>
            	<br/>
            The main purpose of this method is to be the anchor of all of our default virtual
            implementations within this class. We wanted as the framework developers to provide you
            the user with as much default virtual implementation as possible. To do this we needed
            a way to get access to all of the features. For example, we want to create a default
            implementation for finding all of the InternalFeatures in a bounding box. Because this is an
            abstract class we do not know the specifics of the underlying data or how its spatial
            indexes work. What we do know is that if we get all the records then we can brute force
            the answer. In this way if you inherited form this class and only implemented this one
            method we can provide default implementations for virtually every other API.<br/>
            	<br/>
            While this is nice for you the developer if you decide to create your own FeatureSource
            it comes with a price. The price is that it is very inefficient. In the case we just
            discussed about finding all of the InternalFeatures in a bounding box we would not want to look
            at every record to fulfil this method. Instead we would want to override the
            GetFeaturesInsideBoundingBoxCore and implement specific code that would be fast. For
            example in Oracle Spatial there is a specific SQL statement to do this operation very
            quickly. The same holds true with other specific FeatureSource examples.<br/>
            	<br/>
            Most default implementations in the FeatureSource call the
            GetFeaturesInsideBoundingBoxCore which by default calls the GetAllFeaturesCore. It is
            our advice that if you create your own FeatureSource that you ALWAYS override the
            GetFeatureInsideBoundingBox. It will ensure that nearly every other API will operate
            efficiently. Please see the specific API to determine what method it uses.
            </remarks>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetColumnsCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns the columns available for the FeatureSource.</summary>
            <remarks>
            As this is the abstract core version of the Columns method it is intended to
            be overridden in inherited version of the class. When overriding you will be
            responsible for getting a list of all of the columns supported by the FeatureSource. In
            this way the FeatureSource will know what columns are available and will remove any
            extra columns when making calls to other core methods. For example if you have a
            FeatureSource that has three columns of information and the user calls a method and
            requests four columns of information, something they can do with custom fields, we will
            first compare what they are asking for to the results of the GetColumnsCore. In this
            way we can strip out custom columns before calling other Core methods which are only
            responsible for returning data in the FeatureSource. For more information on custom
            fields you can see the documentation on the OnCustomFieldsFetch.
            </remarks>
            <returns>This method returns the columns available for the FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetBoundingBoxCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetBoundingBox. It does not take into account any transaction activity as this is
                the responsibility of the concreate public method GetBoundingBox. In this way as a
                developer if you choose to override this method you do not have to consider
                transaction at all.<br/>
            		<br/>
                The default implementation of GetBoundingBoxCore uses the GetAllRecordsCore method
                to calculate the bounding box of the FeatureSource. We strongly recommend that you
                provide your own implementation for this method that will be more efficient<br/>
            		<br/>
                If you do not override this method the means it gets the BoundingBox is by calling
                the GetAllFeatureCore method and deriving it from each feature. This is a very
                inefficient way to get the BoundingBox in most data sources. It is highly
                recommended that you override this method and replace it with a highly optimized
                version. For example in a ShapeFile the BoundingBox is in the main header of the
                file. Similarly if you are using Oracle Spatial you can execute a simple query to
                get the BoundingBox of all of the record without returning them. In these ways you
                can greatly improve the performance of this method.</para>
            </remarks>
            <summary>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </summary>
            <returns>
            This method returns the bounding box which encompasses all of the features in the
            FeatureSource.
            </returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetFeaturesOutsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <returns>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </returns>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box.
            </summary>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource outside of the
            specified bounding box. If you are in a transaction and that transaction is live then
            it will also take that into consideration.<br/>
            	<br/>
            	<br/>
            The default implementation of GetFeaturesOutsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are outside of the bounding box.
            We strongly recommend that you provide your own implementation for this method that
            will be more efficient
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures outside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetFeaturesInsideBoundingBoxCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box.
            </summary>
            <returns>
            The return decimalDegreesValue is a collection of all of the InternalFeatures that are inside of the
            bounding box.
            </returns>
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesInsideBoundingBoxCore uses the
            GetAllRecordsCore method to determine which InternalFeatures are inside of the bounding box. We
            strongly recommend that you provide your own implementation for this method that will
            be more efficient. It is especially important for this method as many other default
            virtual methods use this for their calculations. We highly recommend when you override
            this method that you use any spatial indexes you have at your disposal to make this
            method as fast as possible.
            </remarks>
            <param name="boundingBox">
            This parameter represents the bounding box you with to find InternalFeatures inside
            of.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetFeaturesForDrawingCore(ThinkGeo.MapSuite.Shapes.RectangleShape,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.String})">
            <remarks>
            This method returns all of the InternalFeatures of this FeatureSource inside of the
            specified bounding box. If you are overriding this method you will not need to consider
            anything about transactions as this is handled by the concreate version of this
            method.<br/>
            	<br/>
            The default implementation of GetFeaturesForDrawingCore uses the
            GetFeaturesInsodeBoundingBoxCore with some optimizations based on the screen width and
            height. For example we can determine is a feature is going to draw in only one to four
            pixels and in that case we may not draw the entire feature but just a subset.
            </remarks>
            <summary>This method returns the InternalFeatures that will be used for drawing.</summary>
            <returns>This method returns the InternalFeatures that will be used for drawing.</returns>
            <param name="boundingBox">This parameter is the bounding box of the InternalFeatures you want to draw.</param>
            <param name="screenWidth">
            This parameter is the width in screen pixels of the canvas you will draw
            on.
            </param>
            <param name="screenHeight">
            This parameter is the height in screen pixels of the canvas you will draw
            on.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetFeaturesByIdsCore(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">In the event you attempt to call this method on a feature source which has not been opened it will throw an InvalidOperationException.</exception>
            <summary>This method returns a collection of InternalFeatures by providing a group of Ids.</summary>
            <returns>This method returns a collection of InternalFeatures by providing a group of Ids.</returns>
            <remarks>
            This method returns a collection of InternalFeatures by providing a group of Ids. The
            internal implementation calls the GetAllFeaturesCore. Because of this if you want an
            efficient version of this method then we high suggest you override the
            GetFeaturesByIdsCore method and provide a fast way to find a group of InternalFeatures by their
            Id.
            </remarks>
            <param name="ids">
            This parameter represents the group of Ids which uniquely identified the InternalFeatures
            in the FeatureSource.
            </param>
            <param name="returningColumnNames">
            This parameter allows you to select the field names of the column data you wish
            to return with each Feature.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureSource.GetCountCore">
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">If the operation is done under source closed state it will throw a InvalidOperationException.</exception>
            <summary>
            This method returns the count of the number of records in this
            FeatureSource.
            </summary>
            <returns>
            This method returns the count of the number of records in this
            FeatureSource.
            </returns>
            <remarks>
            	<para>This protected virtual method is called from the concreate public method
                GetCount. It does not take into account any transaction activity as this is the
                responsibility of the concreate public method GetCount. In this way as a developer
                if you choose to override this method you do not have to consider transaction at
                all.<br/>
            		<br/>
                The default implementation of GetCountCore uses the GetAllRecordsCore method to
                calculate how many records there are in the FeatureSource. We strongly recommend
                that you provide your own implementation for this method that will be more
                efficient<br/>
            		<br/>
                If you do not override this method the means it gets the count is by calling the
                GetAllFeatureCore method and counting each feature. This is a very inefficient way
                to get the count in most data sources. It is highly recommended that you override
                this method and replace it with a highly optimized version. For example in a
                ShapeFile the record count is in the main header of the file. Similarly if you are
                using Oracle Spatial you can execute a simple query to get the count of all of the
                record without returning them. In these ways you can greatly improve the
                performance of this method.</para>
            </remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileHeader.FileLength">
            <summary>
            This variable is in 16-bit decimalDegreesValue.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileIndex.Open(ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>
            Open Files
            </summary>
            <param name="fileAccess">the name of the Shx file</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileIndex.Close">
            <summary>
            Close all the Files
            </summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ShapeFileType">
            <summary>This enumeration represents the types stored in the Shape File.</summary>
            <remarks>
            There are a number of formats as described above that are not currently
            supported. They are primarily not supported because Map Suite is a 2D tool and does not
            currently display 3D graphics.
            </remarks>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.Null">
            <summary>Null</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.Point">
            <summary>Point</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.Polyline">
            <summary>Polyline</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.Polygon">
            <summary>Polygon</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.Multipoint">
            <summary>Multipoint</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.PointZ">
            <summary>PointZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.PolylineZ">
            <summary>PolylineZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.PolygonZ">
            <summary>PolygonZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.MultipointZ">
            <summary>MultiPointZ - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.PointM">
            <summary>PointM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.PolylineM">
            <summary>PolylineM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.PolygonM">
            <summary>PolygonM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.MultipointM">
            <summary>MultipointM - This is currently not supported.</summary>
        </member>
        <member name="F:ThinkGeo.MapSuite.Layers.ShapeFileType.Multipatch">
            <summary>MultiPatch - This is currently not supported.</summary>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer">
            <summary>This layer represents multiple Shape Files of the same type.</summary>
            <remarks>
            This layer represents multiple Shape Files of the same type. Many times, you will have
            multiple Shape Files that represent the same type and you want to draw all of the
            InternalFeatures in each Shape Files the same way. For example, you may have Shape Files that contain roads separated
            by state (TXRoads.shp, FLRoads.shp, etc.) but want them to seem like one layer, draw
            the same way and let you spatially query seamlessly between them. The MultipleShapeFileFeatureLayer
            accomplishes that goal. When you create the layer, you enter a pattern matching criterion -- such as
            C:\Roads\??Roads.shp" -- and the layer will automatically include all of the Shape Files that
            match that pattern.<br/>
            	<br/>
            In addition to this, you can also generate single large indexes that index the multiple
            Shape Files. This means you can have one large road index for all of the road Shape Files,
            instead of having individual indexes for each layer. Not only is this faster to query, but
            it also allows you to minimize the number of files you need.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you need to set
            to required properties manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            If you use this constructor, then you need to set to required properties
            manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the path and filename pattern to match for the
            Shape Files.
            </overloads>
            <remarks>This constructor allows you to pass in the path and filename pattern to match.</remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">
            This parameter is the matching pattern to determine which Shape Files are
            loaded.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to pass in the path and filename patterns to match for the
            Shape Files and their index files.
            </overloads>
            <returns>None</returns>
            <remarks>
            With this constructor you can specify differently-named indexes for the layer. If you have one large
            index, specify its path and filename here. If you have smaller single indexes, use wildcards to specify a
            pattern to match instead.<br/>
            	<br/>
            For example, if you had 50 road Shape Files named C:\Roads\??Roads.shp (where ?? is the two-character state
            abbreviation), but only one large index, then you would specify
            a string like "C:\Roads\Roads.idx". If you instead had 50 individual indexes whose names
            matched the Shape Files, then you would use "C:\Roads\??Roads.idx".
            </remarks>
            <param name="multipleShapeFilePattern">
            This parameter is the path and filename matching pattern that determines which Shape Files are
            loaded.
            </param>
            <param name="indexFilePattern">
            This parameter is the path and filename matching pattern that determines which index files are
            loaded.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>This is the constructor for the class.</summary>
            <overloads>
            This is the  constructor for this class.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the constructor for this class. You can pass in a group of shapes and its corresponding indexs
            like string[] shapeFiles = new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" };
                 string[] indexFiles = new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" };
            In this way, the MultipleShapeFileFeatureLayer will construct from the passing 2 shapes.
            </remarks>
            <param name="shapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="indexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.MultipleShapeFilePattern">
            <summary>
            This property gets and sets the Shape File pattern that makes up this
            layer.
            </summary>
            <value>This property gets the Shape File pattern that makes up this layer.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.IndexFilePattern">
            <summary>
            This property gets and sets the index file pattern that makes up this
            layer.
            </summary>
            <value>This property gets the index file pattern that makes up this layer.</value>
            <remarks>None</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.Encoding">
            <summary>
            This property gets and sets the encoding information for the DBF.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In MultipleShapeFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in a Shape File path and filename pattern. It will generate
            indexes for each Shape File it finds, matching the index file names to the Shape File names.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File path and filename pattern. It will generate
            indexes for each Shape File it finds, matching the index file names to the Shape File names.
            </remarks>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in a Shape File path and filename pattern and determines if we
            rebuild index files that already exist. It will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File path and filename pattern and determines if we
            re-build index files that already exist. It will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names.
            </remarks>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="buildIndexMode">
            This parameter determines whether an index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
            If you use a pattern for the index file name, it will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
            index file name, it will generate one large index instead.
            </overloads>
            <remarks>
            	<para>This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
                If you use a pattern for the index file name, it will generate indexes for each Shape File
                it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
                index file name, it will generate one large index instead.<br/>
            		<br/>
                If you enter an indexFilePattern like "C:\Roads\??Roads.idx",
                it will build individual indexes for each Shape File and name them according to the pattern.
                If you enter an absolute name, like "C:\Roads\Roads.idx", it will create one large index for all of the Shape
                Files.</para>
            </remarks>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="indexFilePattern">
            This parameter is the matching pattern of how to name the index (or
            indexes).
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <remarks>
            	<para>This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
                If you use a pattern for the index file name, it will generate indexes for each Shape File
                it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
                index file name, it will generate one large index instead.<br/>
            		<br/>
                If you enter an indexFilePattern like "C:\Roads\??Roads.idx",
                it will build individual indexes for each Shape File and name them according to the pattern.
                If you enter an absolute name, like "C:\Roads\Roads.idx", it will create one large index for all of the Shape
                Files.</para>
            </remarks>
            <returns>None</returns>
            <overloads>
            This overload allows you to pass in a path and filename pattern for Shapes Files and index files.
            If you use a pattern for the index file name, it will generate indexes for each Shape File
            it finds, matching the index file names to the Shape File names. Alternatively, if you use a concrete
            index file name, it will generate one large index instead. It also allows you to specify what to do
            if an index file already exists.
            </overloads>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="indexFilePattern">
            This parameter is the matching pattern of how to name the index (or
            indexes).
            </param>
            <param name="buildIndexMode">
            This parameter determines whether an index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String,System.String,System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This method builds a single large index file encompassing many Shape Files and allows you to
            select only certain features to include, based on regular expression matching on a column.
            </overloads>
            <returns>None</returns>
            <remarks>
            This index-building method is very useful when you have a large number of Shape
            Files that contain only certain records you want. For example, you may have an individual Shape File
            for the states of Texas and Florida that contains only those states' roads. They are named TXRoads.shp for Texas
            and FLRoads.shp for Florida. Inside of these Shape Files there is a column that determines
            whether the roads are normal streets or highways. You, of course, want to draw highways
            differently. You could use a ValueStyle, but that would be slow because you'd have to look though
            all of the records at runtime to determine which are the highways. A better solution is to
            build a custom index that only has highways in it. In this way, you generate the index
            once and then runtime performance is fast.<br/>
            <br/>
            In our scenario, we would create an index to include all of
            the road Shape Files by using the pattern "*Roads.shp".  This will make sure we get both the Texas and Florida roads.
            Next, we specify the RoadType column as the column parameter. Then we provide a regular
            expression match that picks out all of the highways, and name the resulting index
            "Highways.idx".  We can then build another, separate index just for the normal streets. In this way, we can
            quickly sort the roads from the highways -- and we didn't have to cut up our Shape
            Files to do it.
            </remarks>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="columnName">
            This parameter is the column name you want to apply the regular
            expression towards.
            </param>
            <param name="regularExpression">
            This parameter is the regular expression you want to use to select certain
            features for your index.
            </param>
            <param name="indexFilename">
            This parameter is the name of the index file you want to generate for the features that match
            the regular expression.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <remarks>
            This index-building method is very useful when you have a large number of Shape
            Files that contain only certain records you want. For example, you may have an individual Shape File
            for the states of Texas and Florida that contains only those states' roads. They are named TXRoads.shp for Texas
            and FLRoads.shp for Florida. Inside of these Shape Files there is a column that determines
            whether the roads are normal streets or highways. You, of course, want to draw highways
            differently. You could use a ValueStyle, but that would be slow because you'd have to look though
            all of the records at runtime to determine which are the highways. A better solution is to
            build a custom index that only has highways in it. In this way, you generate the index
            once and then runtime performance is fast.<br/>
            <br/>
            In our scenario, we would create an index to include all of
            the road Shape Files by using the pattern "*Roads.shp".  This will make sure we get both the Texas and Florida roads.
            Next, we specify the RoadType column as the column parameter. Then we provide a regular
            expression match that picks out all of the highways, and name the resulting index
            "Highways.idx".  We can then build another, separate index just for the normal streets. In this way, we can
            quickly sort the roads from the highways -- and we didn't have to cut up our Shape
            Files to do it.
            </remarks>
            <overloads>
            This method builds a single large index file encompassing many Shape Files and allows you to
            select only certain features to include, based on regular expression matching on a column.
            It also allows you to specify what to do if an index file already exists.
            </overloads>
            <returns>None</returns>
            <param name="multipleShapeFilePattern">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="columnName">
            This parameter is the column name you want to apply the regular
            expression towards.
            </param>
            <param name="regularExpression">
            This parameter is the regular expression you want to use to select certain
            features for your index.
            </param>
            <param name="indexFilename">
            This parameter is the name of the index file you want to generate for the features that match
            the regular expression.
            </param>
            <param name="buildIndexMode">
            This parameter determines whether the index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String[],System.String[])">
            <summary>
            This method builds a spatial index for the layer.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
            <param name="buildIndexMode">
            This parameter determines whether the index file will be rebuilt if it already
            exists.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.BuildIndex(System.String[],System.String[],ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method builds a spatial index for the layer.
            </summary>
            <param name="multipleShapeFiles">
            This parameter represents the shape files to construct the MultipleShapeFileFeatureLayer. The format of it should be
            new string[] { "C:\CA_counties.shp", "C:\AZ_counties.shp" }.
            </param>
            <param name="multipleShapeFileIndexes">
            This parameter represents the shape files to construct the ShapeFileFeatureLayer. The format of it should be
             new string[] { "C:\CA_counties.midx", "C:\AZ_counties.midx" }.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.GetShapePathFilenames">
            <summary>
            This method returns a collection of the Shape Files and their paths that make up the
            layer.
            </summary>
            <returns>
            This method returns a collection of the Shape Files and their paths that make up the
            layer.
            </returns>
            <remarks>None</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.MultipleShapeFileFeatureLayer.GetIndexPathFilenames">
            <summary>
            This method returns a collection of the index files and their paths that make up the
            layer.
            </summary>
            <returns>
            This method returns a collection of the index files and their paths that make up the
            layer.
            </returns>
            <remarks>None</remarks>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer">
            <summary>This class represents a Layer backed by a Shape File.</summary>
            <remarks>None</remarks>
        </member>
        <member name="E:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.StreamLoading">
            <summary>
            This event allows you to pass in your own stream to represent the files.
            </summary>
            <remarks>
            If you choose you can pass in your own stream to represent the file. The
            stream can come from a variety of places such as isolated storage, a compressed file,
            and encrypted stream. When the Image is finished with the stream it will dispose
            of it so be sure to keep this in mind when passing the stream in. If you do not pass in
            a alternate stream the class will attempt to load the file from the file system
            using the PathFilename property.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.#ctor">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This is the default constructor. If you use this constructor, then you should set
            the required methods manually.
            </overloads>
            <returns>None</returns>
            <remarks>
            This is the default constructor. If you use this constructor, then you should set
            the required methods manually.
            </remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.#ctor(System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a shape
            file.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.#ctor(System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File and
            the read/write mode for the files.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="readWriteMode">This parameter specifies whether the file will be opened in read-only or read/write mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.#ctor(System.String,System.String)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File and its
            spatial index file.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="indexPathFilename">This parameter is the index file path and filename.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File, its
            index file, and to specify the read/write mode for the files.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="indexPathFilename">This parameter is the index file path and filename.</param>
            <param name="readWriteMode">This parameter specifies whether the file will be opened in read-only or read/write mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.#ctor(System.String,System.String,ThinkGeo.MapSuite.Layers.GeoFileReadWriteMode,System.Text.Encoding)">
            <summary>This is a constructor for the class.</summary>
            <overloads>
            This constructor allows you to provide a path and filename to a Shape File, the
            index file, and to specify the read/write mode and the encoding for the files.
            </overloads>
            <returns>None</returns>
            <remarks>None</remarks>
            <param name="shapePathFilename">This parameter is the Shape File path and filename.</param>
            <param name="indexPathFilename">This parameter is the index file path and filename.</param>
            <param name="readWriteMode">This parameter specifies whether the file will be opened in read-only or read/write mode.</param>
            <param name="encoding">This parameter specifies the encoding of the data.</param>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.HasBoundingBox">
            <summary>
            This property checks to see if a Layer has a BoundingBox or not. If it has no
            BoundingBox, it will throw an exception when you call the GetBoundingBox() and
            GetFullExtent() APIs. In ShapeFileFeatureLayer, we override this API and mark it as true.
            </summary>
            <remarks>The default implementation in the base class returns false.</remarks>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.UsingSpatialIndex">
            <summary>
            This property gets whether the Shape File FeatureSource has an index or not.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.Encoding">
            <summary>
            This property gets and sets the encoding information for the DBF.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.ShapePathFilename">
            <summary>
            This property returns the path and filename of the Shape File you want to
            represent.
            </summary>
            <value>
            This property returns the path and filename of the Shape File you want to
            represent.
            </value>
            <remarks>
            None
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid PathFilename structure will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.IndexPathFilename">
            <summary>
            This property returns the path and filename of the index file you want to
            represent.
            </summary>
            <value>
            This property returns the path and filename of the index file you want to
            represent.
            </value>
            <remarks>
            None
            </remarks>
            <exception cref="T:System.ArgumentException" caption="ArgumentException">Setting an invalid PathFilename structure will throw an ArgumentException.</exception>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.RequireIndex">
            <summary>
            This property gets and sets whether an index is required when reading data. The default value is true.
            </summary>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.Rebuild(System.String)">
            <summary>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file.
            </summary>
            <returns>None</returns>
            <remarks>
            This method rebuilds the SHP, SHX, DBF, IDX and IDS files for the given shape
            file. When we do editing we have optimized the updates so that we do not need to
            rebuild the entire shape file. This leads to the shape file being out of order which
            may cause it not to open in other tools. One optimization is if you update a record
            instead of rebuilding a new shape file we mark the old record as null and add the
            edited record at the end of the shape file. This greatly increases the speed of
            committing shape file changes but will over time unorder the shape file. In addition we
            do a delete the DBF file will simply mark the record deleted and not compact the space.
            Rebuilding the shape file will correctly order the SPX and SHX along with compacting
            the DBF file and rebuild any index with the same any of the shape file if it
            exists.<br/>
            	<br/>
            Note that if you have build custom index files where the name of the index differs from
            that of the shape file you will need to rebuild those manually using the BuildIndex
            methods.
            </remarks>
            <param name="shapePathFilename">This parameter is the shape file you want to rebuild.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.CreateShapeFile(ThinkGeo.MapSuite.Layers.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.DbfColumn})">
            <summary>
            Static API to create a new Shape File.
            </summary>
            <param name="shapeType">This parameter specifies the the Shape File type for the target Shape File.</param>
            <param name="pathFilename">This parameter specifies the Shape filename for the target Shape File.</param>
            <param name="databaseColumns">This parameter specifies the DBF column information for the target Shape File.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.CreateShapeFile(ThinkGeo.MapSuite.Layers.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.DbfColumn},System.Text.Encoding)">
            <summary>
            Static API to create a new Shape File.
            </summary>
            <param name="shapeType">This parameter specifies the the Shape File type for the target Shape File.</param>
            <param name="pathFilename">This parameter specifies the Shape filename for the target Shape File.</param>
            <param name="databaseColumns">This parameter specifies the DBF column information for the target Shape File.</param>
            <param name="encoding">This parameter specifies the DBF encoding infromation for the target Shape File.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.CreateShapeFile(ThinkGeo.MapSuite.Layers.ShapeFileType,System.String,System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Layers.DbfColumn},System.Text.Encoding,ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            Static API to create a new Shape File.
            </summary>
            <param name="shapeType">This parameter specifies the the Shape File type for the target Shape File.</param>
            <param name="pathFilename">This parameter specifies the Shape filename for the target Shape File.</param>
            <param name="databaseColumns">This parameter specifies the DBF column information for the target Shape File.</param>
            <param name="encoding">This parameter specifies the DBF encoding infromation for the target Shape File.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target Shape File exists.</param>
            <remarks>An exception will be thown when the target Shape File does not exist while the overwrite mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.String)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in the Shape filename.
            </overloads>
            <returns>None</returns>
            <remarks>This overload allows you to pass in the Shape File.</remarks>
            <param name="pathFilename">The path and filename to the Shape File.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>
            This method build a spatial index for the shape file which increases accessspeed.
            </summary>
            <overloads>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </overloads>
            <remarks>
            This overload builds an index file with the same name as the shape file with only
            the extension being different. You can also specify if you want to rebuild an existing
            index file.
            </remarks>
            <returns>None</returns>
            <param name="shapePathFilename">
            This parameter is the shape file name and path that you want to build an index
            for.
            </param>
            <param name="indexPathFilename">
            This parameter specifies the index file name.
            </param>
            <param name="buildIndexMode">
            This parameter determines what will happen if there is an existing index
            file.
            </param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index for the layer.</summary>
            <overloads>
            This overload allows you to pass in the Shape File and determines if we
            rebuild an index file that already exists.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in the Shape File and determines if we
            rebuild an index file that already exists.
            </remarks>
            <param name="pathFilename">This parameter is the matching pattern that defines which Shape Files to include.</param>
            <param name="rebuildExistingIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String)">
            <summary>This method builds a spatial index for the specified group of features.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify the index filename to use.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter specifies the target index path and filename.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String,ThinkGeo.MapSuite.Shapes.Projection)">
            <summary>This method builds a spatial index for the specified group of features and target projection.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter specifies the target index path and filename.</param>
            <param name="projection">This parameter specifies the projection to build index against those features.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index for the specified group of features.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify the index filename to use.
            You can also pass in a Shape File and specify whether to rebuild an index file if it already exists.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.Collections.Generic.IEnumerable{ThinkGeo.MapSuite.Shapes.Feature},System.String,ThinkGeo.MapSuite.Shapes.Projection,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index for the specified group of features.</summary>
            <overloads>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            You can also pass in a Shape File and specify whether to rebuild an index file if it already exists.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a group of features and specify a target projection and the index filename to use.
            </remarks>
            <param name="features">This parameter specifies the features for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="projection">This parameter determines the Projection to build index against those features.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index only for those features that satisfy a regular expression.</summary>
            <overloads>
            This overload allows you to pass in a Shape File and only build an index for those features that satisfy the
            regularExpression parameter.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File and specify the index filename to use.
            </remarks>
            <param name="shapePathFilename">This parameter specifies the Shape File for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="columnName">This parameter determines the column name whose values will be tested against the regular expression.</param>
            <param name="regularExpression">This parameter represents the regular expression to test against each feature for inclusion in the index.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode)">
            <summary>This method builds a spatial index only for those features that satisfy a regular expression, based on a passed-in projection.</summary>
            <overloads>
            This overload allows you to pass in a Shape File and only build an index for those features that satisfy the
            regularExpression parameter.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File and specify the index filename to use.
            </remarks>
            <param name="shapePathFilename">This parameter specifies the Shape File for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="projection">This parameter determines the projection that will be used to build the index against those features that satisfy the regular expression.</param>
            <param name="columnName">This parameter determines the column name whose values will be tested against the regular expression.</param>
            <param name="regularExpression">This parameter represents the regular expression to test against each feature for inclusion in the index.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildIndexFile(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,System.String,System.String,ThinkGeo.MapSuite.Layers.BuildIndexMode,System.Text.Encoding)">
            <summary>This method builds a spatial index only for those features that satisfy a regular expression, based on a passed-in projection.</summary>
            <overloads>
            This overload allows you to pass in a Shape File and only build an index for those features that satisfy the
            regularExpression parameter.
            </overloads>
            <returns>None</returns>
            <remarks>
            This overload allows you to pass in a Shape File and specify the index filename to use.
            </remarks>
            <param name="shapePathFilename">This parameter specifies the Shape File for which to build the index.</param>
            <param name="indexPathFilename">This parameter determines the target index path filename.</param>
            <param name="projection">This parameter determines the projection that will be used to build the index against those features that satisfy the regular expression.</param>
            <param name="columnName">This parameter determines the column name whose values will be tested against the regular expression.</param>
            <param name="regularExpression">This parameter represents the regular expression to test against each feature for inclusion in the index.</param>
            <param name="buildIndexMode">This parameter determines whether an index file will be rebuilt if it already exists.</param>
            <param name="encoding">This parameter specifies the encoding information used in the source DBF file.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.CloneShapeFileStructure(System.String,System.String)">
            <summary>
            Clone the structure from the source ShapeFile to the target ShapeFile. After cloning the structure,
            the target ShapeFile will have the same type and the same DBF columns as the source ShapeFile, but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source Shape File to be cloned.</param>
            <param name="targetShapePathFilename">The target Shape File, which will have the same structure as the source Shape File after cloning operation is complete.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            Clone the structure from the source ShapeFile to the target ShapeFile. After cloning the structure,
            the target ShapeFile will have the same type and the same DBF columns as the source ShapeFile, but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source Shape File to be cloned.</param>
            <param name="targetShapePathFilename">The target Shape File, which will have the same structure as the source Shape File after cloning operation is complete.</param>
            <param name="overwriteMode">This parameter specifies the overwrite mode when the target ShapeFile already exists.</param>
            <remarks>An exception will be thown when the target ShapeFile does not exist and the overwrite mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.CloneShapeFileStructure(System.String,System.String,ThinkGeo.MapSuite.Layers.OverwriteMode,System.Text.Encoding)">
            <summary>
            Clone the structure from the source ShapeFile to the target ShapeFile. After cloning the structure,
            the target ShapeFile will have the same type and the same DBF columns as the source ShapeFile, but without any records in it.
            </summary>
            <param name="sourceShapePathFilename">The source Shape File to be cloned.</param>
            <param name="targetShapePathFilename">The target Shape File, which will have the same structure as the source Shape File after cloning operation is complete.</param>
            <param name="overwriteMode">This parameter specifies the overwrite mode when the target ShapeFile already exists.</param>
            <param name="encoding"> This parameter specifies the encoding information in the source Shape File.</param>
            <remarks>An exception will be thown when the target ShapeFile does not exist and the overwrite mode is set to DoNotOverwrite.</remarks>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildRecordIdMode)">
            <summary>
            Static API used to build RecordId. The Id will start from 0.
            </summary>
            <param name="shapeFilename">The name of the target ShapeFile on which to base the newly built RecordId.</param>
            <param name="fieldname">The field name for the RecordId.</param>
            <param name="rebuildNeeded">The RecordId build mode.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildRecordIdMode,System.Int32)">
            <summary>
            Static API used to build RecordId from the specified starting Id number.
            </summary>
            <param name="shapeFilename">The name of the target ShapeFile on which to base the newly built RecordId.</param>
            <param name="fieldname">The field name for the RecordId.</param>
            <param name="rebuildNeeded">The RecordId build mode.</param>
            <param name="startNumber">The starting Id number of the RecordId.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.BuildRecordIdColumn(System.String,System.String,ThinkGeo.MapSuite.Layers.BuildRecordIdMode,System.Int32,System.Text.Encoding)">
            <summary>
            Static API used to build RecordId from the specified starting Id number.
            </summary>
            <param name="shapeFilename">The name of the target ShapeFile on which to base the newly built RecordId.</param>
            <param name="fieldname">The field name for the RecordId.</param>
            <param name="rebuildNeeded">The RecordId build mode.</param>
            <param name="startNumber">The starting Id number of the RecordId.</param>
            <param name="encoding"> This parameter specifies the encoding information in the DBF.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.GetShapeFileType">
            <summary>
            Get the Shape File type for the Shape File FeatureSource.
            </summary>
            <returns>The ShapeFileType for the ShapeFile FeatureSource.</returns>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.SaveToProjection(System.String,System.String,ThinkGeo.MapSuite.Shapes.Projection,ThinkGeo.MapSuite.Layers.OverwriteMode)">
            <summary>
            This API provide a easy way to project features in a shape file into another projection and save it to shape file.
            </summary>
            <param name="sourceShapeFile">This parameter specifies the source shape file to be projected.</param>
            <param name="targetShapeFile">This parameter specifies the target shape file to be saved for the projected features. </param>
            <param name="projection">This parameter is the projection to project the source shape file to target shape file. The source
            Shape file should be in the FromProjection of the Projection prameter, and the targetShapeFile will be in the ToProjection
            of the Projection.</param>
            <param name="overwriteMode">This parameter specifies the override mode when the target shape file exists.</param>
        </member>
        <member name="M:ThinkGeo.MapSuite.Layers.ShapeFileFeatureLayer.Validate">
            <summary>
            This method checks all features in a shapefile is supported by Mapsuite or not.
            </summary>
            <returns>A dictionary which contains all the unsupported features. The key is the Indexs which
            failed to pass the check, the value contains the reason for its failure.</returns>
        </member>
        <member name="T:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.DbfColumnsIsEmpty">
            <summary>
              Looks up a localized string similar to The DbfColumns collection is empty, you should add at least one DbfColumn when you create a new shape file..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.DecimalLengthInValidForStringColumnType">
            <summary>
              Looks up a localized string similar to DecimalLength is Invalid(it should be 0) for StringColumnType, it only make sense for DoubleColumnType..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.EnumerationOutOfRange">
            <summary>
              Looks up a localized string similar to The value for the enumeration is not one of the valid values..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.FeatureIsNotValid">
            <summary>
              Looks up a localized string similar to The Feature you provided is not valid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.FileAccessError">
            <summary>
              Looks up a localized string similar to File access error, you should open the shape file with ReadWrite mode..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.IndexFileNotExisted">
            <summary>
              Looks up a localized string similar to You don&apos;t have the corresponding idx file for your shape file. You can use the static method ShapeFileFeatureSource.BuildIndexFile() or ShapeFileFeatureLayer.BuildIndexFile()  to build an idx file for the shape file, or you can set the RequireIndex property to false..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.InvalidOperationOnALockedVariable">
            <summary>
              Looks up a localized string similar to It cannot be changed  until the layer/featureSource is closed.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ProjectionIsNotOpen">
            <summary>
              Looks up a localized string similar to The projection is not open.  Please open it before calling this method..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.RecordIsInvalid">
            <summary>
              Looks up a localized string similar to The record is invalid, please call Validate method to check the failed reason..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ShapeFileBoundingBoxIsValid">
            <summary>
              Looks up a localized string similar to The shape file bounding box is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ShapefileFeatureSourceIdNotFromZero">
            <summary>
              Looks up a localized string similar to The Shapefile Id is one based, zero is an invalid Id..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ShapeFileInnerRingNotContainedInOuterRing">
            <summary>
              Looks up a localized string similar to An InnerRing doesn&apos;t contained in any OuterRing..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ShapeFileNameIsInvalid">
            <summary>
              Looks up a localized string similar to The shape file name is invalid..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ShapeIsInvalidForValidation">
            <summary>
              Looks up a localized string similar to There are no points in the shape..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.ShapeTypeNotImplement">
            <summary>
              Looks up a localized string similar to This shape has not been implemented yet..
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.UnsupportedEditingShapeType">
            <summary>
              Looks up a localized string similar to Currently we do not support editing this kind of shape type. Shape type:.
            </summary>
        </member>
        <member name="P:ThinkGeo.MapSuite.Layers.ShapeFileExceptionDescription.NotSupported">
            <summary>
              Looks up a localized string similar to This feature is currently not supported..
            </summary>
        </member>
    </members>
</doc>
